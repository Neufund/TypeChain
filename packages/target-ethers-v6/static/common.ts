/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { Result, FunctionFragment, Typed, EventFragment } from 'ethers/types/abi'
// import type {  } from "ethers/types/abi/fragments";
import type {
  ContractEvent,
  // ContractMethodArgs,
  ContractTransaction,
  // ContractMethod,
  ContractTransactionResponse,
  DeferredTopicFilter,
  EventLog,
} from 'ethers/types/contract'
// import type { Listener } from 'ethers/src.ts/utils'
import type { TransactionRequest } from 'ethers/types/providers'

export interface TypedDeferredTopicFilter<_TCEvent extends TypedContractEvent> extends DeferredTopicFilter {}

export interface TypedContractEvent<ArgsTuple extends Array<any> = any, ArgsObject = any> {
  (...args: Partial<ArgsTuple>): TypedDeferredTopicFilter<TypedContractEvent<ArgsTuple, ArgsObject>>
  name: string
  fragment: EventFragment
  getFragment(...args: Partial<ArgsTuple>): EventFragment
}

type __TypechainArgsTuple<T> = T extends TypedContractEvent<infer U> ? U : never
type __TypechainArgsObject<T> = T extends TypedContractEvent<infer _U, infer W> ? W : never

export interface TypedEventLog<TCEvent extends TypedContractEvent> extends Omit<EventLog, 'args'> {
  args: __TypechainArgsTuple<TCEvent> & __TypechainArgsObject<TCEvent>
}

export type TypedListener<TCEvent extends TypedContractEvent> = (
  ...listenerArg: [...__TypechainArgsTuple<TCEvent>, TypedEventLog<TCEvent>, ...undefined[]]
) => void

export type MinEthersFactory<C, ARGS> = {
  deploy(...a: ARGS[]): Promise<C>
}

export type GetContractTypeFromFactory<F> = F extends MinEthersFactory<infer C, any> ? C : never
export type GetARGsTypeFromFactory<F> = F extends MinEthersFactory<any, any> ? Parameters<F['deploy']> : never

export type StateMutability = 'nonpayable' | 'payable' | 'view'

export type BaseOverrides = Omit<TransactionRequest, 'to' | 'data'>
export type NonPayableOverrides = Omit<BaseOverrides, 'value' | 'blockTag' | 'enableCcipRead'>
export type PayableOverrides = Omit<BaseOverrides, 'blockTag' | 'enableCcipRead'>
export type ViewOverrides = Omit<TransactionRequest, 'to' | 'data'>
export type Overrides<S extends StateMutability> = S extends 'nonpayable'
  ? NonPayableOverrides
  : S extends 'payable'
  ? PayableOverrides
  : ViewOverrides

export type PostfixOverrides<A extends Array<any>, S extends StateMutability> = A | [...A, Overrides<S>]
export type ContractMethodArgs<A extends Array<any>, S extends StateMutability> = PostfixOverrides<
  { [I in keyof A]-?: A[I] | Typed },
  S
>

export type DefaultReturnType<R> = R extends Array<any> ? R[0] : R

// export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {
export interface TypedContractMethod<
  A extends Array<any> = Array<any>,
  R = any,
  S extends StateMutability = 'payable',
> {
  (...args: ContractMethodArgs<A, S>): S extends 'view'
    ? Promise<DefaultReturnType<R>>
    : Promise<ContractTransactionResponse>

  name: string

  fragment: FunctionFragment

  getFragment(...args: ContractMethodArgs<A, S>): FunctionFragment

  populateTransaction(...args: ContractMethodArgs<A, S>): Promise<ContractTransaction>
  staticCall(...args: ContractMethodArgs<A, S>): Promise<DefaultReturnType<R>>
  send(...args: ContractMethodArgs<A, S>): Promise<ContractTransactionResponse>
  estimateGas(...args: ContractMethodArgs<A, S>): Promise<bigint>
  staticCallResult(...args: ContractMethodArgs<A, S>): Promise<R>
}

// export type NonPayableContractMethod<A extends any[] = any[], R = any> = ContractMethod<A, R, 'nonpayable'>
// export type PayableContractMethod<A extends any[] = any[], R = any> = ContractMethod<A, R, 'payable'> // TODO improve override typing
// export type ViewContractMethod<A extends any[] = any[], R = any> = ContractMethod<A, R, 'view'>
